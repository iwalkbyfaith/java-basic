package arrays1;

import java.util.Arrays;

public class Arrays01 {
	public static void main(String[] args) {
		
		// ★★★★★★ 이진 탐색(binary search)은 탐색 알고리즘 중 상위권의 성능을 보여주는 알고리즘입니다. (효율성 극상) ★★★★★★

		// 다만, 실행에 앞선 전제조건으로
		// 1. 배열 내부에 중복되는 값이 없을 것 						=> 중복이 안되면 실행 자체가 안됨.
		// 2. 배열이 오름차순(작은 숫자일수록 0번 인덱스에 가깝게)이어야 함
		
		// 이진탐색을 보완한 보간탐색 나중에 검색해보자
		
		// 정렬이 안 된 상태의 배열 내부를 탐색할 때는 찾지 못함.
		int[] arr1 = {5, 2, 6, 12, 8, 4, 0, 5};
		
		// 이진 탐색 수행 명령어 : Arrays.binarySearch(배열명, 찾는 값);
		int a = Arrays.binarySearch(arr1, 0);
		System.out.println(a);
			// 0이라는 값이 있지만 실행하면 -1(못찾았다)라고 나옴.
			// 근데 0을 배열의 왼쪽 부분에 놓으면 값이 나온다 ;;
			// Q) 왜? 
			// A) 밑에 설명. 정렬이 안 되어도 운이 좋으면 찾는 경우도 있음.
		
		
		// 이진 탐색을 알려면 순차 탐색부터 알아야한다.
		// 순차 탐색
		// 예를 들어 5, 7, 6, 1, 3, 9, 0, 12 배열 내부에 이런 데이터가 들어가 있을때
		// arr1의 배열에서 0을 찾을거야 했을때
		// 순차 탐색은 arr1의 '0번째'부터 찾는 것. 0을 0번과 비교 -> 1번과 비교 -> ... -> 6번과 비교(발견)
		// 순차 탐색의 장점 : 내부에 정렬되어 있지 않은 숫자에서도 탐색이 가능. (사전 준비가 필요 없음)
		// 순차 탐색의 단점 : 찾는 자료가 뒤에 있으면 있을수록 속도가 느려짐.(성능이 안좋음) (만약 찾는 자료가 8천만번 째에 있다면?)
		
		// 성능 측정이라는 측면은 '못찾을 때'를 기준으로 한다.
		// 왜? 알고리즘이 아무리 구려도 찾는 자료가 0번째에 있는 경우가 있음. -> 이 경우를 근거로, 구린 알고리즘이 좋다고 평가할 순 없으니까.
		// 몇 번을 뒤졌더니 찾았는가?를 기준으로. (1억개 데이터를 기준으로 하면 1억번 비교를 해야 할 수도 있음)
		
		// 이진탐색의 경우는?
		// 전제 조건 1, 2 확인.
		// 0, 1, 3, 7, 15, 21, 38, 40
		// 내가 찾는 것이 21이다라고 할 때 이진 탐색이 돌아가는 로직
		// 가운데를 찾음(0번 7번 인덱스를 더해서 2로 나눔 => 자바에서 7/2 = 3)
		//   -> 3번에 있는 값(7)과 21을 비교 -> 7보다 작은 애는 다 왼쪽 인덱스에 있으니 더 큰 수를 찾으려면 오른쪽으로 가야지
		//   -> (비교 한번에 4개=절반의 인덱스를 다 걸렀음)
		//   -> 인덱스 4 + 7 /2 = 5 -> 5번인덱스(21)와 21을 비교 -> 발견
		//   => 두 번만에 21이 몇 번 인덱스에 있는지 찾음.
		//   Q) 없는 수인 51의 경우였다면? 
		//       -> 5번 인덱스인 21은 다르기 때문에, 6 + 7 /2 = 6번 인덱스
		//       -> 6번 인덱스(38)와 비교. 아님 -> 7+7/2 = 7번 인덱스
		//       -> 7번(40)과 51을 비교. 오른쪽에 데이터 없음. -> 없는 것을 확인
		//       => 네 번만에 처리가 됨.
		// ===> 장점 : 절반씩 제끼면서 자료를 찾아서 속도가 빠름.
		
		// 이진 탐색시 정렬이 안 되어 있다면?
		// 5, 7, 6, 1, 3, 9, 0, 12
		// 첫 시도시 3번인덱스(1)과 0을 비교. 오른쪽을 다 걸러버림 (0도 버려짐 . . )
		// 0 + 2 / 2 = 1. 7과 0을 비교 -> 5와 0을 비교 -> 없네 -> 끝
		
		
		// 정렬이 된 상태의 배열을 탐색하는 경우
		int[] arr2 = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20};
		int b = Arrays.binarySearch(arr2, 14);
		System.out.println(b); // 7번 인덱스에 14가 있다고 정확하게 찍어줌.
		
		
		
	}
}
